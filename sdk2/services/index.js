import{combineSignedTransactions,combineSignedTransactionsWithoutLambda,createRandomMessage,createSeed,formTransaction,getMasterPublicKey,parseTransaction,preRegister,registerStepOne,registerStepTwo,registerStepThree,reshareSignTransaction,reshareStepByOriginalGroup,reshareStepOneByNewUser,reshareStepThree,reshareStepTwo,signTransaction,signTransactionWithoutLambda,getPolybaseKey}from"./cryptography/index.js";import{createVault,preRegisterStep,proposeTransaction,userCompleteVault,userConfirmTx,registerUserAll,registerUserAllReshare}from"./web3/signerfunctions.js";import{getFilteredUserInitializedLogs,getFilteredUserInitializedLogsSingle,getFilteredUserInitializedLogsSingleWithDeoa,_getProposal,_getTransaction,_getTransactions,_getTransactionLean,getVault}from"./web3/providerfunctions.js";import{getUserPreRegisterInfos,getUserSignature,getUtilsParams,getUserRegistrationAllInfos,getRegistrationStep3InfosDB,getRegistrationReshareStep3InfosDB}from"./web3/utils.js";import{ethers}from"ethers";import{hexToBytes}from"@noble/hashes/utils";import ws from"ws";import{finalizeEvent,getPublicKey}from"nostr-tools/pure";import{Relay}from"nostr-tools/relay";import{SimplePool}from"nostr-tools";import{parseEther}from"viem";import{createViemClientForTransaction,getVaultContract}from"./web3/helper/index.js";import{getProviderForChain}from"../tools/chainList.js";import{subscribeToQuery}from"../tools/graph.js";async function createIntuAccount(e,a,t,r,n,i,s=!1){var o=(await createSeed()).seed,l=(await createRandomMessage()).message;return await createVault(e,a,t,r,n,l,o,i,s)}async function createPolybaseKey(e,a,t){let r="";return r=t||await getUserSignature(e,a),getPolybaseKey(r)}async function preRegistration(e,a,t,r){var n=await a.getAddress();if((await getUserPreRegisterInfos(e,n,a.provider)).registered)return console.log("user already preregistered : ",n),"User already preregistered : "+n;let i;i=t||await getUserSignature(e,a);var{encryptionKey:n,megaPublicKey:t,encMegaSecretKey:s}=await preRegister(i),o=(await getPolybaseKey(i)).key,o=getPublicKey(hexToBytes(String(o)));return preRegisterStep(e,n,t,s,o,a,r||!1)}async function automateRegistration(r,n,e,a){console.log("automateRegistration is starting");let p=Date.now();var t=await n.provider?.getNetwork().then(e=>e.chainId);let d=0,_=50,u="",i=a=>new Promise(e=>setTimeout(e,a)),s=(u=a||await getUserSignature(r,n),await n.getAddress()),{users:h,createdDate:V}=await(await getVaultContract(r,n.provider)).vaultInfos(),m,o,y,w,f,l,b=h.findIndex(e=>s==e);if(421614===t)console.log("waiting 2 minutes for all users to pre-register"),await new Promise(a=>{let t=subscribeToQuery("subscribeToVaultUserPreRegister",{vaultAddress:r},{next:async e=>{console.log("Raw subscription data:",e),e&&"object"==typeof e&&(e=e.data?.VaultUserPreRegister,console.log("PreRegister data:",e),Array.isArray(e))&&0<e.length&&(e=await getUtilsParams(r,s,n.provider),l=[...e.dbKeyArray],m=e.seed,y=e.index,w=e.megaPkArray,f=e.encMegaSecretKey[b],o=e.threshold,e=l.filter(Boolean).length,console.log(`Current registered users: ${e}/`+h.length),l.filter(Boolean).length>=h.length)&&(t.unsubscribe(),a())},error:e=>{t.unsubscribe(),a()},complete:()=>{t.unsubscribe(),a()}}),e=setTimeout(()=>{console.log("Timeout reached for pre-registration"),t.unsubscribe(),a()},12e4);return()=>{console.log("Cleaning up pre-registration subscription"),clearTimeout(e),t.unsubscribe()}});else for(;l.filter(Boolean).length<h.length&&d<_;){await i(750);var g=await getUtilsParams(r,s,n.provider);l=[...g.dbKeyArray],m=g.seed,y=g.index,w=g.megaPkArray,f=g.encMegaSecretKey[b],o=g.threshold,d++}let v=Math.ceil(w.length*o/100),T=[],k=[],S=[],P=[],A=[],R=[],D=[],K=[],N=[],U=[],L=[],M=[],J=[],z=[],E=[];E=new Array(h.length).fill("");var c,a=["wss://nostr.intu.xyz"];e&&a.unshift(e);let I=[];for(c of a)try{await Relay.connect(c),I.push(c);break}catch(e){console.error(`Error connecting to relay ${c}:`,e)}if(0===I.length)throw new Error("No relays available");let C=new SimplePool,O=(await getPolybaseKey(u)).key,x;try{if(!(x=C.subscribeMany(I,[{kinds:[1],authors:l,since:Number(V)}],{onevent(e){e=JSON.parse(e.content);"pedersen_key_dealing"in e?(P[e.u]=e.pedersen_key_dealing,A[e.u]=e.pedersen_kappa_dealing,R[e.u]=e.pedersen_lambda_dealing,T[e.u]=1):"simple_key_dealing"in e?(D[e.u]=e.pedersen_key_opening,K[e.u]=e.pedersen_kappa_opening,N[e.u]=e.pedersen_lambda_opening,U[e.u]=e.simple_key_dealing,L[e.u]=e.simple_lambda_dealing,M[e.u]=e.pedersen_key_transcript,J[e.u]=e.pedersen_kappa_transcript,z[e.u]=e.pedersen_lambda_transcript,k[e.u]=1):"dealing_kappa_times_lambda"in e&&(E[e.u]=e.dealing_kappa_times_lambda,S[e.u]=1)}})))throw new Error("Failed to create subscription")}catch(e){throw console.error("Error connecting to NOSTR relay(s): "+I+" ERROR: ",e),e}t=(await registerStepOne(m,v,y,w)).pedersenDealingArray,e={u:b,pedersen_key_dealing:t[0],pedersen_kappa_dealing:t[1],pedersen_lambda_dealing:t[2]},a={kind:1,created_at:Math.floor(Date.now()/1e3),content:JSON.stringify(e),tags:[]},t=finalizeEvent(a,hexToBytes(String(O)));await C.publish(I,t);let B=!1;return await(async()=>{try{for(console.log("performing crypto work");!B;)try{await i(500),d++,await(async()=>{try{if(d>_)return!1;var e,a,t,r,n,i,s,o,l,g,c,p;if(!(B=P.length===h.length&&U.length===h.length&&E.length===h.length&&E.every(Boolean)?!0:B))if(console.log("round1counter : "+T.filter(Number).length),T.filter(Number).length!==h.length||D[b]?D[b]&&k.filter(Number).length!==h.length&&console.log("waiting on others to do step 2 --- so we can do step3"):({pedersenOpeningArray:e,simpleDealingArray:a,pedersenTranscriptArray:t}=await registerStepTwo(m,v,y,w,u,f,P,A,R),r={u:b,pedersen_key_opening:e[0],pedersen_kappa_opening:e[1],pedersen_lambda_opening:e[2],simple_key_dealing:a[0],simple_lambda_dealing:a[1],pedersen_key_transcript:t[0],pedersen_kappa_transcript:t[1],pedersen_lambda_transcript:t[2]},n={kind:1,created_at:Math.floor(Date.now()/1e3),content:JSON.stringify(r),tags:[]},i=finalizeEvent(n,hexToBytes(String(O))),await C.publish(I,i),process.env.DEBUG&&console.log("second step COMPLETE")),console.log("round2counter : "+k.filter(Number).length),k.filter(Number).length!==h.length||E[b]||""!=E[b]?E[b]&&S.filter(Number).length!==h.length&&console.log("You are all done! Waiting on others to perform step3 so we can complete vault"):(console.log("doinground3"),{simpleOpeningArray:s,multiplyDealingArray:o,simpleTranscriptArray:l}=await registerStepThree(m,v,y,w,u,f,U,L,M[b],J[b],N[b]),g={u:b,simple_key_opening:s[0],simple_kappa_opening:s[1],dealing_key_times_lambda:o[0],dealing_kappa_times_lambda:o[1],simple_key_transcript:l[0],simple_kappa_transcript:l[1]},c={kind:1,created_at:Math.floor(Date.now()/1e3),content:JSON.stringify(g),tags:[]},p=finalizeEvent(c,hexToBytes(String(O))),await C.publish(I,p)),S.filter(Number).length===h.length)return console.log("EVERYONE IS DONE"),B=!0,await x.close(),!0}catch(e){console.error("An error occurred in bigUpdater:",e)}})()}catch(e){break}var e=Date.now();return process.env.DEBUG&&console.log(`Completed in ${e-p} ms`),!0}catch(e){return console.log("error::",e),!1}})(),await x.close(),!0}async function registerAllSteps(e,a,t,r,n){let i="";n=n||!1;i=t||await getUserSignature(e,a);let s="",o="",l="",g="",c="",p="",d="",_="",u=[],h=[],m,y;var w,t=await getPolybaseKey(i),t=getPublicKey(hexToBytes(String(t.key))),f=new SimplePool,b=["wss://nostr.intu.xyz"],v=(r&&b.unshift(r),[]);for(w of b)try{await Relay.connect(w),v.push(w);break}catch(e){console.error(`Error connecting to relay ${w}:`,e)}if(0===v.length)throw new Error("No relays available");let T=f.subscribeMany(v,[{authors:[t]}],{onevent(e){e=JSON.parse(e.content);e.pedersen_key_dealing&&(u=[e.pedersen_key_dealing,e.pedersen_kappa_dealing,e.pedersen_lambda_dealing]),e.pedersen_key_opening&&(s=e.pedersen_key_opening),e.pedersen_kappa_opening&&(o=e.pedersen_kappa_opening),e.pedersen_lambda_opening&&(l=e.pedersen_lambda_opening),e.simple_key_dealing&&(g=e.simple_key_dealing),e.simple_lambda_dealing&&(c=e.simple_lambda_dealing),e.pedersen_key_transcript&&(p=e.pedersen_key_transcript),e.pedersen_kappa_transcript&&(d=e.pedersen_kappa_transcript),e.pedersen_lambda_transcript&&(_=e.pedersen_lambda_transcript),e.simple_key_opening&&(h=[e.simple_key_opening,e.simple_kappa_opening,e.dealing_key_times_lambda,e.dealing_kappa_times_lambda,e.simple_key_transcript,e.simple_kappa_transcript]),1<u.length&&(m=btoa(JSON.stringify(u))),1<h.length&&(y=btoa(JSON.stringify(h)))},oneose(){T.close()}});for(;!(m&&s&&o&&l&&g&&c&&p&&d&&_&&y);)await(a=>new Promise(e=>setTimeout(e,a)))(500);return registerUserAll(e,m,s,o,l,g,c,p,d,_,y,a,n)}async function registerAllReshareSteps(e,a,t,r,n){let i="",s=(i=t||await getUserSignature(e,a),""),o="",l="",g="",c="",p="",d="",_="",u,h,m=[],y=[];var w,t=n||!1,n=await getPolybaseKey(i),n=getPublicKey(hexToBytes(String(n.key))),f=new SimplePool,b=["wss://nostr.intu.xyz"],v=(r&&b.unshift(r),[]);for(w of b)try{await Relay.connect(w),v.push(w);break}catch(e){console.error(`Error connecting to relay ${w}:`,e)}if(0===v.length)throw new Error("No relays available");let T=f.subscribeMany(v,[{authors:[n]}],{onevent(e){e=JSON.parse(e.content);e.simple_kappa_dealing_reshared_once&&(m=[e.simple_key_dealing_reshared_once,e.simple_kappa_dealing_reshared_once,e.simple_lambda_dealing_reshared_once]),e.simple_key_opening_reshared_once&&(s=e.simple_key_opening_reshared_once),e.simple_kappa_opening_reshared_once&&(o=e.simple_kappa_opening_reshared_once),e.simple_lambda_opening_reshared_once&&(l=e.simple_lambda_opening_reshared_once),e.simple_key_dealing_reshared_twice&&(g=e.simple_key_dealing_reshared_twice),e.simple_kappa_dealing_reshared&&(c=e.simple_kappa_dealing_reshared),e.transcript_key_reshared_once&&(p=e.transcript_key_reshared_once),e.transcript_kappa_reshared_once&&(d=e.transcript_kappa_reshared_once),e.transcript_lambda_reshared_once&&(_=e.transcript_lambda_reshared_once),e.simple_key_opening_reshared_twice&&(y=[e.simple_key_opening_reshared_twice,e.simple_kappa_opening_reshared_twice,e.dealing_key_times_lambda_reshare,e.dealing_kappa_times_lambda_reshare,e.simple_key_transcript_reshared_twice,e.simple_kappa_transcript_reshared_twice]),1<m.length&&(u=btoa(JSON.stringify(m))),1<y.length&&(h=btoa(JSON.stringify(y)))},oneose(){T.close()}});for(;!(u&&s&&o&&l&&g&&c&&p&&d&&_&&h);)await(a=>new Promise(e=>setTimeout(e,a)))(500);return registerUserAllReshare(e,u,s,o,l,g,c,p,d,_,h,a,t)}async function completeVault(g,c,a){let n=async(a,t=5,r=1e3)=>{try{return await a()}catch(e){if(0===t)throw e;return await new Promise(e=>setTimeout(e,r)),n(a,t-1,r)}};return n(async()=>{var e=a||!1,{users:t,completed:r}=await(await getVaultContract(g,c.provider)).vaultInfos();if(r)return"Vault is already completed.";if(3<=t.length){r=[t[0],t[1],t[2]];let a=await c.getAddress();try{var n=await getUserRegistrationAllInfos(g,c.provider),i=(n&&n.length,n.some(e=>null!==e),t.findIndex(e=>a.toLowerCase()===e.toLowerCase()));if(-1===i)throw new Error("User not found in vault members");n[0]&&n[1]&&n[2],n[i]||console.log("User registration data not yet available, retrying...");var s=n[i].step3Crypto;try{var o=JSON.parse(atob(s));if(!Array.isArray(o)||o.length<5)throw new Error("Invalid step3Result format: "+JSON.stringify(o));var l=await getMasterPublicKey(o[4]);return await userCompleteVault(g,r,"0x"+l,c,e)}catch(e){console.error("Error :",e)}}catch(e){throw e}}return"Not enough users or data not available"})}async function submitTransaction(e,a,t,r,n,i,s,o,l,g="n/a",c=!1,p){var d=new Date;let _;_=p?"string"==typeof p?new ethers.providers.StaticJsonRpcProvider(p):p:await getProviderForChain(t);p=await createViemClientForTransaction(_);await l.getAddress();let u;var h=await _.getFeeData();if(null==i||""===i){if(!h.gasPrice)throw new Error("Unable to determine gas price");u=h.gasPrice.mul(105).div(100)}else u=ethers.BigNumber.from(i);let m=null;h=(await(await getVaultContract(o,l.provider)).vaultInfos()).masterPublicKey;try{m=n?await p.estimateGas({account:h,to:e,value:parseEther(String(a)),data:n}):await p.estimateGas({account:h,to:e,value:parseEther(String(a))})}catch(e){return console.warn(`You are likely experiencing an error because the account ${h} doesn't have enough funds to cover the gas+value being requested to transfer on `+t),void console.log(e)}let y;if(null==s||""===s){if(!m)throw new Error("Unable to determine gas limit");y=ethers.BigNumber.from(m).mul(105).div(100)}else y=ethers.BigNumber.from(s);i=await formTransaction(e,String(a),String(t),String(r),String(n),u.toString(),y.toString(),String(18)),p=await proposeTransaction(o,i,l,g,c),h=new Date;return process.env.DEBUG&&console.log("SUBMIT TX TIME : ",h.getTime()-d.getTime()),p}async function submitTransactionSolana(e,a,t,r="n/a"){console.log("data being stored : ",e);var n=new Date,e=await formTransaction("0x0000000000000000000000000000000000000000","0","0","0",e,"0","0",String(0)),a=await proposeTransaction(a,e,t,r,!1),e=new Date;return process.env.DEBUG&&console.log("SUBMIT TX TIME : ",e.getTime()-n.getTime()),a}async function signTx(a,t,r,n,i,s){var o=new Date;let l=await r.getAddress(),g="",c,e,p,d,_,u;s=s||!1;g=n||await getUserSignature(a,r);var{users:n,resharingOccurred:h}=await(await getVaultContract(a,r.provider)).vaultInfos(),n=n.findIndex(e=>l==e),m=(d&&_&&u&&e&&p||(m=await getUtilsParams(a,l,r.provider),d=m.seed,_=m.threshold,u=m.index,e=m.megaPkArray,p=m.encMegaSecretKey[n]),Math.ceil(e.length*_/100));if("bigint"==typeof t?t=Number(t):"string"==typeof t&&(t=parseInt(t,10)),!c){var y=await getTransactionLean(a,t,r.provider);if(!y)throw new Error("Transaction not found : "+a+" "+t);if(""===y.transactionData)throw new Error("Transaction data is empty : "+a+" "+t);console.log("Transaction data type:",typeof y.transactionData),console.log("Transaction data:",y.transactionData),c=y.transactionData}var y=await getUserRegistrationAllInfos(a,r.provider),n=y[n],w=m;if(y&&""!==n.step3Crypto){var f,y=JSON.parse(atob(n.step3Crypto));let e;h?(h=n.pedersenOpeningLambdaReshare,f=await getRegistrationReshareStep3InfosDB(a,r.provider),e=await reshareSignTransaction(d,w,u,c,g,p,f.pedersenDealingsLambdaReshareArray,f.dealingsKeyXLambdaReshareArray,f.dealingsKappaXLambdaReshareArray,h||"",y[4],y[5])):({dealingKeyXLambdaArray:w,dealingKappaXLambdaArray:f}=await getRegistrationStep3InfosDB(a,r.provider),i?e=await signTransactionWithoutLambda(d,c,g,y[0],y[1],y[4],y[5]):(h=new Date,e=await signTransaction(d,m,u,c,g,p,w,f,n.pedersenOpeningLambda||"",y[4],y[5],n.pedersenTranscriptLambda||""),i=new Date,console.log("sign transaction CRYPTO : "+(i.getTime()-h.getTime())/1e3)));m=new Date;return process.env.DEBUG&&console.log("Time to sign : "+(m.getTime()-o.getTime())/1e3),userConfirmTx(a,t,e.signedTransaction,r,s)}}async function combineSignedTx(a,e,t,r){let n=await t.getAddress();var i;let s,o,l,g,c=(await(await getVaultContract(a,t.provider)).vaultInfos()).users;var p;c.findIndex(e=>n==e);if(s&&o&&l||(d=await getUtilsParams(a,n,t.provider),s=d.seed,o=d.threshold,l=d.megaPkArray),!g){let e=null;for(p of await getUserRegistrationAllInfos(a,t.provider))if(p&&p.user&&p.user.toLowerCase()===n.toLowerCase()){e=p;break}g=e.step3Crypto}var d=JSON.parse(atob(g)),_=Math.ceil(l.length*o/100);let u=0,h=new Array(c.length).fill(""),m;for(;h.filter(e=>""!==e).length<_&&u<10;)console.log("checking for signatures, attempt : "+u),u++,i=await getTransaction(a,e="bigint"==typeof e?Number(e):e,t.provider),console.log("tx : ",i),m=i.transactionData,i.userSignedTransactions.forEach(a=>{var e=c.findIndex(e=>e.toLowerCase()===a.user.toLowerCase());-1!==e?h[e]=a.signedTransaction:h.push("")}),await(a=>new Promise(e=>setTimeout(e,a)))(1e3);let y;if(h.length<2)throw new Error("Hmm, one of the signing nodes failed to do it's job, sorry about that, please try again!");var w=h.filter(e=>""!==e);if(r){if(console.log("signedTransactions 2 : ",h),1<h.length)return(y=await combineSignedTransactionsWithoutLambda(s,_,m||"",h,d[4],d[5])).finalSignedTransaction}else if(1<w.length)return(y=await combineSignedTransactions(s,_,m||"",h,d[4],d[5])).finalSignedTransaction}async function getVaults(a,t){var e;return console.log("start get vaults"),0===await t.getTransactionCount(a)||(e=await getFilteredUserInitializedLogs(a,t))&&0===e.length||void 0===e?[]:(e=e&&await Promise.all(e.map(async e=>getVault(e,t))),Promise.all(e.filter(e=>e.users.some(e=>e.address===a)).map(async a=>{for(let e=1;e<=a.proposalCount;e++);var e=[],e=await getAllTransactions(a.vaultAddress,t);return{...a,proposals:[],transactions:e}})).then(e=>e))}async function getVaultSingle(e,a){if(0===await a.getTransactionCount(e))return null;e=await getFilteredUserInitializedLogsSingle(e,a);if(!e?.length)return null;var e=e[e.length-1],t=await getVault(e,a),r=[];for(let e=1;e<=t.proposalCount;e++)r.push(await getProposal(t.vaultAddress,e,a));e=await getAllTransactions(t.vaultAddress,a);return{...t,proposals:r,transactions:e}}async function getVaultsWithoutTransactions(e,a){return 0===await a.getTransactionCount(e)||(e=await getFilteredUserInitializedLogs(e,a))&&0===e.length||void 0===e?[]:e&&await Promise.all(e.map(async e=>getVault(e,a)))}async function getVaultSingleWithDEOA(e,r){var e=await getFilteredUserInitializedLogsSingleWithDeoa(e,r);return e&&0===e.length||void 0===e?[]:(e=e&&await Promise.all(e.map(async e=>getVault(e,r))),Promise.all(e.map(async a=>{var t=[];for(let e=1;e<=a.proposalCount;e++)t.push(await getProposal(a.vaultAddress,e,r));var e=[],e=await getAllTransactions(a.vaultAddress,r);return{...a,proposals:t,transactions:e}})).then(e=>e))}async function getAllTransactions(e,a){var t=new Date,e=await _getTransactions(e,a).then(async e=>Promise.all(e.map(async e=>{var a=await parseTransaction(e.transactionData);return{id:e.txId,transactionData:e.transactionHash,chainId:a.chainId,data:a.data,gas:a.gas,gasPrice:a.gasPrice,nonce:a.nonce,to:a.to,value:a.value,signedTransactionsNeeded:e.signedTransactionsNeeded,userSignedTransactions:e.userSignedTransactions,transactionNotes:e.transactionNotes}}))),a=new Date;return process.env.DEBUG&&console.log("Time to get all transactions : ",a.getTime()-t.getTime()),e}"undefined"==typeof window&&(global.WebSocket=ws);let retryWithDelay=async(a,t=3,r=1e3)=>{try{return await a()}catch(e){if(0===t)throw e;return await new Promise(e=>setTimeout(e,r)),retryWithDelay(a,t-1,r)}};async function getTransaction(t,r,n){return retryWithDelay(async()=>{var e,a=await _getTransaction(t,r,n);if(a?.transactionData)return e=await parseTransaction(a.transactionData),{...a,chainId:e.chainId,data:e.data,gas:e.gas,gasPrice:e.gasPrice,nonce:e.nonce,to:e.to,value:e.value};throw new Error("Transaction data not available")})}async function getTransactionLean(t,r,n){return retryWithDelay(async()=>{var e,a=await _getTransactionLean(t,r,n);if(a?.transactionData)return e=await parseTransaction(a.transactionData),{...a,chainId:e.chainId,data:e.data,gas:e.gas,gasPrice:e.gasPrice,nonce:e.nonce,to:e.to,value:e.value};throw new Error("Transaction data not available")})}async function automateRotateRegistration(e,a,t){let d=await getUserSignature(e,a);var r=await a.getAddress(),n=await getVaultContract(e,a.provider),{users:i,createdDate:s}=await n.vaultInfos();let _,o,u,h,l,m,y;var g=[],c=await n.getUserToAdd();let p=await n.getUserToRemove();if(r===p[0])throw new Error("User being removed cannot particpate");let w=a=>new Promise(e=>setTimeout(e,a)),f=await a.getAddress(),b=(g=i.concat(c)).findIndex(e=>f==e);console.log("encMegaSecretKey being set to this userindex : "+b);n=await getUtilsParams(e,f,a.provider);_=n.seed,u=n.megaPkArray,h=n.encMegaSecretKey[b],o=n.threshold,l=n.dbKeyArray;let v;p&&p[0]&&""!==p[0]?(i=g.findIndex(e=>p[0]==e),console.log("userIndexToBeRemoved : "+i),m=g.length-1,c&&c[0]&&c[0]==f||b):m=g.length;i=g.findIndex(e=>e===p[0]),0<=i&&1===c.length&&(console.log(i+" : "+p[0]),g[i]=g[g.length-1],l[i]=l[g.length-1],u[i]=u[g.length-1],h=n.encMegaSecretKey[b],g.pop(),l.pop(),u.pop()),c[0]===f&&(b=i),v=Math.ceil(u.length*o/100),n=await getUserRegistrationAllInfos(e,a.provider);let T,k=(""!==(T=(c.includes(r)?n[0]:n[b]).step3Crypto)&&(g=JSON.parse(atob(T)),y=g[4]),await w(500),[]),S=[],P=[],A=[],R=[],D=[],N=[],B=[],V=[],K=[],L=[],M=[],J=[],z=[],W=[],F=[],G=[],U=[],j=[],$=[];var E,i=["wss://nostr.intu.xyz"];t&&i.unshift(t);let I=[];for(E of i)try{await Relay.connect(E),I.push(E);break}catch(e){console.error(`Error connecting to relay ${E}:`,e)}if(0===I.length)throw new Error("No relays available");let C=(await getPolybaseKey(d)).key,O=new SimplePool;try{O.subscribeMany(I,[{kinds:[1],authors:l,since:Number(s)}],{onevent(e){e=JSON.parse(e.content);console.log("data : "+e.u),"simple_kappa_dealing_reshared_once"in e?(A[e.u]=e.simple_key_dealing_reshared_once,R[e.u]=e.simple_kappa_dealing_reshared_once,D[e.u]=e.simple_lambda_dealing_reshared_once,k[e.u]=1):"simple_key_opening_reshared_once"in e?(N[e.u]=e.simple_key_opening_reshared_once,B[e.u]=e.simple_kappa_opening_reshared_once,V[e.u]=e.simple_lambda_opening_reshared_once,K[e.u]=e.simple_key_dealing_reshared_twice,L[e.u]=e.simple_kappa_dealing_reshared,M[e.u]=e.transcript_key_reshared_once,J[e.u]=e.transcript_kappa_reshared_once,z[e.u]=e.transcript_lambda_reshared_once,S[e.u]=1):"simple_key_opening_reshared_twice"in e&&(W[e.u]=e.simple_key_opening_reshared_twice,F[e.u]=e.simple_kappa_opening_reshared_twice,G[e.u]=e.dealing_key_times_lambda_reshare,U[e.u]=e.dealing_kappa_times_lambda_reshare,j[e.u]=e.simple_key_transcript_reshared_twice,$[e.u]=e.simple_kappa_transcript_reshared_twice,P[e.u]=1)}})}catch(e){console.error("Error subscribing to relays:",e)}c.includes(r)?(n=(await reshareStepOneByNewUser(_,v,b,u)).reshareDealings,g={u:b,simple_key_dealing_reshared_once:"",simple_kappa_dealing_reshared_once:n[0],simple_lambda_dealing_reshared_once:n[1]},t={kind:1,created_at:Math.floor(Date.now()/1e3),content:JSON.stringify(g),tags:[]},i=finalizeEvent(t,hexToBytes(String(C))),await O.publish(I,i),console.log("resharestep1done")):(s=await getUserSignature(e,a),c=await getUserRegistrationAllInfos(e,a.provider),r=JSON.parse(atob(c[b].step3Crypto))[0],n=(await reshareStepByOriginalGroup(_,v,b,s,r,u)).reshareDealings,g={u:b,simple_key_dealing_reshared_once:n[0],simple_kappa_dealing_reshared_once:n[1],simple_lambda_dealing_reshared_once:n[2]},t={kind:1,created_at:Math.floor(Date.now()/1e3),content:JSON.stringify(g),tags:[]},i=finalizeEvent(t,hexToBytes(String(C))),await O.publish(I,i));let x=!1,X=async()=>{try{var e,a,t,r,n,i,s,o,l,g,c,p;if(D.length===m&&K.length===m&&U.length===m&&U.every(e=>e&&0<e.length)&&(console.log("Completing"),x=!0),!x)if(console.log("Round1counter "+k.filter(Number).length),k.filter(Number).length!==m||N[b]?N[b]&&(S.filter(Number).length,m):(A=A.filter(e=>""!==e),R.includes("")&&(R=R.filter(e=>""!==e)),D.includes("")&&(D=D.filter(e=>""!==e)),{reshareOpenings:e,reshareDealings:a,reshareTranscripts:t}=await reshareStepTwo(_,v,b,u,d,h,A,y,R,D),r={u:b,simple_key_opening_reshared_once:e[0],simple_kappa_opening_reshared_once:e[1],simple_lambda_opening_reshared_once:e[2],simple_key_dealing_reshared_twice:a[0],simple_kappa_dealing_reshared:a[1],transcript_key_reshared_once:t[0],transcript_kappa_reshared_once:t[1],transcript_lambda_reshared_once:t[2]},n={kind:1,created_at:Math.floor(Date.now()/1e3),content:JSON.stringify(r),tags:[]},i=finalizeEvent(n,hexToBytes(String(C))),await O.publish(I,i),console.log("resharestep2done")),console.log("Round2counter "+S.filter(Number).length),S.filter(Number).length!==m||W[b]?U[b]&&P.filter(Number).length!==m&&console.log("You are all done! Waiting on others to perform step3 so we can complete vault"):(console.log("doingstep3"),{reshareOpenings:s,reshareDealings:o,reshareTranscripts:l}=await reshareStepThree(_,v,b,u,d,h,L,V,A,M[b],J[b]),g={u:b,simple_key_opening_reshared_twice:s[0],simple_kappa_opening_reshared_twice:s[1],dealing_key_times_lambda_reshare:o[0],dealing_kappa_times_lambda_reshare:o[1],simple_key_transcript_reshared_twice:l[0],simple_kappa_transcript_reshared_twice:l[1]},c={kind:1,created_at:Math.floor(Date.now()/1e3),content:JSON.stringify(g),tags:[]},p=finalizeEvent(c,hexToBytes(String(C))),await O.publish(I,p),console.log("resharestep3done")),P.filter(Number).length===m)return console.log("EVERYONE IS DONE"),x=!0}catch(e){}};return X(),await(async()=>{for(;!x;)await w(1e3),X();return!0})(),await O.close(I),!0}async function getProposal(e,a,t){return _getProposal(e,a,t,ethers.utils.defaultAbiCoder)}async function getProposedUser(e,a){return(await getVaultContract(e,a)).getUserToAdd()}async function getUserCompletedRotationRegistrationCount(e,a){return(await(await getVaultContract(e,a)).userToAddCount()).toNumber()}export{createIntuAccount,createPolybaseKey,preRegistration,automateRegistration,registerAllSteps,registerAllReshareSteps,completeVault,submitTransaction,submitTransactionSolana,signTx,combineSignedTx,getVaults,getVaultSingle,getVaultsWithoutTransactions,getVaultSingleWithDEOA,getAllTransactions,getTransaction,getTransactionLean,automateRotateRegistration,getProposal,getProposedUser,getUserCompletedRotationRegistrationCount};